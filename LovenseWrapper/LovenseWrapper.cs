// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace LovenseWrapper
{
    /// <summary>Abstract class</summary>
    // DEBUG: class LOVENSE_EXTERN ILovenseSDKNotify
    // DEBUG: {
    // DEBUG: 	public:
    // DEBUG: 		/*Call when toy search start*/
    // DEBUG: 		virtual	void LovenseDidSearchStart() = 0;
    // DEBUG: 
    // DEBUG: 		/*Call when toy searching toy*/
    // DEBUG: 		virtual  void LovenseSearchingToys(lovense_toy_info_t *info) = 0;
    // DEBUG: 
    // DEBUG: 		/*Call when Something went wrong*/
    // DEBUG: 		virtual  void LovenseErrorOutPut(int errorCode,const char *errorMsg) = 0;
    // DEBUG: 
    // DEBUG: 		/*Call when toy search end*/
    // DEBUG: 		virtual  void LovenseDidSearchEnd() = 0;
    // DEBUG: 
    // DEBUG: 		/*Call when send cmd start*/
    // DEBUG: 		virtual	void LovenseDidSendCmdStart() = 0;
    // DEBUG: 
    // DEBUG: 		/*Call when send cmd return*/
    // DEBUG: 		virtual  void LovenseSendCmdResult(const char * szToyID, CLovenseToy::CmdType cmd,const char *result,CLovenseToy::Error errorCode) = 0;
    // DEBUG: 
    // DEBUG: 		/*Call when send cmd end*/
    // DEBUG: 		virtual	void LovenseDidSendCmdEnd() = 0;
    // DEBUG: 
    // DEBUG: 		/*Call when toy connected, or disconnected*/
    // DEBUG: 		virtual void LovenseToyConnectedStatus(const char *szToyID, bool isConnected) = 0;
    // DEBUG: }
    public unsafe abstract partial class ILovenseSDKNotify : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        internal partial struct __Internal
        {
            internal __IntPtr vfptr_ILovenseSDKNotify;

            [SuppressUnmanagedCodeSecurity, DllImport("LovenseToys", EntryPoint = "??0ILovenseSDKNotify@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("LovenseToys", EntryPoint = "??0ILovenseSDKNotify@@QEAA@AEBV0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        internal __IntPtr __Instance { get; private set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::LovenseWrapper.ILovenseSDKNotify> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::LovenseWrapper.ILovenseSDKNotify>();

        internal bool __ownsNativeInstance;

        internal static ILovenseSDKNotify __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ILovenseSDKNotifyInternal(native.ToPointer(), skipVTables);
        }

        internal static ILovenseSDKNotify __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ILovenseSDKNotify)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ILovenseSDKNotify __GetInstance(__IntPtr native)
        {
            if (!NativeToManagedMap.TryGetValue(native, out var managed))
                throw new global::System.Exception("No managed instance was found");
            var result = (ILovenseSDKNotify)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static ILovenseSDKNotify __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ILovenseSDKNotifyInternal(native, skipVTables);
        }

        internal ILovenseSDKNotify(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        // DEBUG: ILovenseSDKNotify
        internal ILovenseSDKNotify()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::LovenseWrapper.ILovenseSDKNotify.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "LovenseWrapper.ILovenseSDKNotify");
        }

        // DEBUG: ILovenseSDKNotify
        internal ILovenseSDKNotify(global::LovenseWrapper.ILovenseSDKNotify _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::LovenseWrapper.ILovenseSDKNotify.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
            SetupVTables(GetType().FullName == "LovenseWrapper.ILovenseSDKNotify");
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            ((global::LovenseWrapper.ILovenseSDKNotify.__Internal*) __Instance)->vfptr_ILovenseSDKNotify = __VTables.Tables[0];
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        // DEBUG: virtual	void LovenseDidSearchStart() = 0
        public abstract void LovenseDidSearchStart();

        // DEBUG: virtual  void LovenseSearchingToys(lovense_toy_info_t *info) = 0
        public abstract void LovenseSearchingToys(global::LovenseWrapper.StLovenseToyInfo info);

        // DEBUG: virtual  void LovenseErrorOutPut(int errorCode,const char *errorMsg) = 0
        public abstract void LovenseErrorOutPut(int errorCode, string errorMsg);

        // DEBUG: virtual  void LovenseDidSearchEnd() = 0
        public abstract void LovenseDidSearchEnd();

        // DEBUG: virtual	void LovenseDidSendCmdStart() = 0
        public abstract void LovenseDidSendCmdStart();

        // DEBUG: virtual  void LovenseSendCmdResult(const char * szToyID, CLovenseToy::CmdType cmd,const char *result,CLovenseToy::Error errorCode) = 0
        public abstract void LovenseSendCmdResult(string szToyID, global::LovenseWrapper.CLovenseToy.CmdType cmd, string result, global::LovenseWrapper.CLovenseToy.Error errorCode);

        // DEBUG: virtual	void LovenseDidSendCmdEnd() = 0
        public abstract void LovenseDidSendCmdEnd();

        // DEBUG: virtual void LovenseToyConnectedStatus(const char *szToyID, bool isConnected) = 0
        public abstract void LovenseToyConnectedStatus(string szToyID, bool isConnected);

        #region Virtual table interop

        // void LovenseDidSearchStart() = 0
        private static global::LovenseWrapper.Delegates.Action___IntPtr _LovenseDidSearchStartDelegateInstance;

        private static void _LovenseDidSearchStartDelegateHook(__IntPtr __instance)
        {
            var __target = global::LovenseWrapper.ILovenseSDKNotify.__GetInstance(__instance);
            __target.LovenseDidSearchStart();
        }

        // void LovenseSearchingToys(lovense_toy_info_t *info) = 0
        private static global::LovenseWrapper.Delegates.Action___IntPtr___IntPtr _LovenseSearchingToysDelegateInstance;

        private static void _LovenseSearchingToysDelegateHook(__IntPtr __instance, __IntPtr info)
        {
            var __target = global::LovenseWrapper.ILovenseSDKNotify.__GetInstance(__instance);
            var __result0 = global::LovenseWrapper.StLovenseToyInfo.__GetOrCreateInstance(info, false);
            __target.LovenseSearchingToys(__result0);
        }

        // void LovenseErrorOutPut(int errorCode,const char *errorMsg) = 0
        private static global::LovenseWrapper.Delegates.Action___IntPtr_int_string8 _LovenseErrorOutPutDelegateInstance;

        private static void _LovenseErrorOutPutDelegateHook(__IntPtr __instance, int errorCode, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string errorMsg)
        {
            var __target = global::LovenseWrapper.ILovenseSDKNotify.__GetInstance(__instance);
            __target.LovenseErrorOutPut(errorCode, errorMsg);
        }

        // void LovenseDidSearchEnd() = 0
        private static global::LovenseWrapper.Delegates.Action___IntPtr _LovenseDidSearchEndDelegateInstance;

        private static void _LovenseDidSearchEndDelegateHook(__IntPtr __instance)
        {
            var __target = global::LovenseWrapper.ILovenseSDKNotify.__GetInstance(__instance);
            __target.LovenseDidSearchEnd();
        }

        // void LovenseDidSendCmdStart() = 0
        private static global::LovenseWrapper.Delegates.Action___IntPtr _LovenseDidSendCmdStartDelegateInstance;

        private static void _LovenseDidSendCmdStartDelegateHook(__IntPtr __instance)
        {
            var __target = global::LovenseWrapper.ILovenseSDKNotify.__GetInstance(__instance);
            __target.LovenseDidSendCmdStart();
        }

        // void LovenseSendCmdResult(const char * szToyID, CLovenseToy::CmdType cmd,const char *result,CLovenseToy::Error errorCode) = 0
        private static global::LovenseWrapper.Delegates.Action___IntPtr_string8_LovenseWrapper_CLovenseToy_CmdType_string8_LovenseWrapper_CLovenseToy_Error _LovenseSendCmdResultDelegateInstance;

        private static void _LovenseSendCmdResultDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string szToyID, global::LovenseWrapper.CLovenseToy.CmdType cmd, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string result, global::LovenseWrapper.CLovenseToy.Error errorCode)
        {
            var __target = global::LovenseWrapper.ILovenseSDKNotify.__GetInstance(__instance);
            __target.LovenseSendCmdResult(szToyID, cmd, result, errorCode);
        }

        // void LovenseDidSendCmdEnd() = 0
        private static global::LovenseWrapper.Delegates.Action___IntPtr _LovenseDidSendCmdEndDelegateInstance;

        private static void _LovenseDidSendCmdEndDelegateHook(__IntPtr __instance)
        {
            var __target = global::LovenseWrapper.ILovenseSDKNotify.__GetInstance(__instance);
            __target.LovenseDidSendCmdEnd();
        }

        // void LovenseToyConnectedStatus(const char *szToyID, bool isConnected) = 0
        private static global::LovenseWrapper.Delegates.Action___IntPtr_string8_bool _LovenseToyConnectedStatusDelegateInstance;

        private static void _LovenseToyConnectedStatusDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string szToyID, bool isConnected)
        {
            var __target = global::LovenseWrapper.ILovenseSDKNotify.__GetInstance(__instance);
            __target.LovenseToyConnectedStatus(szToyID, isConnected);
        }

        internal static class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[8];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();

            static VTableLoader()
            {
                _LovenseDidSearchStartDelegateInstance += _LovenseDidSearchStartDelegateHook;
                _LovenseSearchingToysDelegateInstance += _LovenseSearchingToysDelegateHook;
                _LovenseErrorOutPutDelegateInstance += _LovenseErrorOutPutDelegateHook;
                _LovenseDidSearchEndDelegateInstance += _LovenseDidSearchEndDelegateHook;
                _LovenseDidSendCmdStartDelegateInstance += _LovenseDidSendCmdStartDelegateHook;
                _LovenseSendCmdResultDelegateInstance += _LovenseSendCmdResultDelegateHook;
                _LovenseDidSendCmdEndDelegateInstance += _LovenseDidSendCmdEndDelegateHook;
                _LovenseToyConnectedStatusDelegateInstance += _LovenseToyConnectedStatusDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_LovenseDidSearchStartDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_LovenseSearchingToysDelegateInstance);
                Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LovenseErrorOutPutDelegateInstance);
                Thunks[3] = Marshal.GetFunctionPointerForDelegate(_LovenseDidSearchEndDelegateInstance);
                Thunks[4] = Marshal.GetFunctionPointerForDelegate(_LovenseDidSendCmdStartDelegateInstance);
                Thunks[5] = Marshal.GetFunctionPointerForDelegate(_LovenseSendCmdResultDelegateInstance);
                Thunks[6] = Marshal.GetFunctionPointerForDelegate(_LovenseDidSendCmdEndDelegateInstance);
                Thunks[7] = Marshal.GetFunctionPointerForDelegate(_LovenseToyConnectedStatusDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 8);
                            ManagedVTables[0][0] = Thunks[0];
                            ManagedVTables[0][1] = Thunks[1];
                            ManagedVTables[0][2] = Thunks[2];
                            ManagedVTables[0][3] = Thunks[3];
                            ManagedVTables[0][4] = Thunks[4];
                            ManagedVTables[0][5] = Thunks[5];
                            ManagedVTables[0][6] = Thunks[6];
                            ManagedVTables[0][7] = Thunks[7];
                            VTables.Methods[0] = new Delegate[8];
                            if (destructorOnly)
                                return VTables;
                        }
                    }
                }

                *(IntPtr**)(instance + 0) = ManagedVTables[0];
                return VTables;
            }
        }

        internal CppSharp.Runtime.VTables __vtables;

        internal virtual CppSharp.Runtime.VTables __VTables
        { 
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {        
                __vtables = value;
            }
        }

        internal virtual void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }

    // DEBUG: class LOVENSE_EXTERN CLovenseToyManager
    // DEBUG: {
    // DEBUG: 	public:
    // DEBUG: 		/**
    // DEBUG: 		Pass your token into Lovense framework
    // DEBUG: 		*/
    // DEBUG: 		virtual bool SetDeveloperToken(const char *szToken) = 0;
    // DEBUG: 
    // DEBUG: 		/**
    // DEBUG: 		 Subscription notification
    // DEBUG: 		 */
    // DEBUG: 		virtual void RegisterEventCallBack(ILovenseSDKNotify * lovenseNotify) = 0;
    // DEBUG: 
    // DEBUG: 		/**
    // DEBUG: 		Search for Lovense toys
    // DEBUG: 		*/
    // DEBUG: 		virtual int StartSearchToy() = 0;
    // DEBUG: 
    // DEBUG: 		/**
    // DEBUG: 		 Stop searching
    // DEBUG: 		*/
    // DEBUG: 		virtual int StopSearchToy() = 0;
    // DEBUG: 
    // DEBUG: 		/**
    // DEBUG: 		Send a command to the toy
    // DEBUG: 
    // DEBUG: 		@param toyId toy ID
    // DEBUG: 		@param commandType command
    // DEBUG: 		@param paramDict command parameters
    // DEBUG: 		*/
    // DEBUG: 		virtual int SendCommand(const char * szToyID, CLovenseToy::CmdType cmd, int nParam) = 0;
    // DEBUG: 
    // DEBUG: 		/**
    // DEBUG: 		Connect a toy
    // DEBUG: 
    // DEBUG: 		@param toyId toy ID
    // DEBUG: 		If Successful connection successfully, will call LovenseToyConnectedStatus;
    // DEBUG: 		*/
    // DEBUG: 		virtual int ConnectToToy(const char * szToyID) = 0;
    // DEBUG: 
    // DEBUG: 		/**
    // DEBUG: 		DisConnect a toy
    // DEBUG: 
    // DEBUG: 		@param toyId toy ID
    // DEBUG: 		return Successfully disconnected, will call LovenseToyConnectedStatus;
    // DEBUG: 		*/
    // DEBUG: 		virtual int DisConnectedToy(const char *szToyID) = 0;
    // DEBUG: 
    // DEBUG: 
    // DEBUG: 		/**
    // DEBUG: 		Get toy battery
    // DEBUG: 
    // DEBUG: 		@param toyId toy ID
    // DEBUG: 		return 0
    // DEBUG: 		*/
    // DEBUG: 		virtual int GetToyBattery(const char* szToyID, int *battery_out) = 0;
    // DEBUG: }

    public unsafe abstract partial class CLovenseToyManager : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        internal partial struct __Internal
        {
            internal __IntPtr vfptr_CLovenseToyManager;

            [SuppressUnmanagedCodeSecurity, DllImport("LovenseToys", EntryPoint = "??0CLovenseToyManager@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("LovenseToys", EntryPoint = "??0CLovenseToyManager@@QEAA@AEBV0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        internal __IntPtr __Instance { get; private set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::LovenseWrapper.CLovenseToyManager> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::LovenseWrapper.CLovenseToyManager>();

        internal bool __ownsNativeInstance;

        internal static CLovenseToyManager __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new CLovenseToyManagerInternal(native.ToPointer(), skipVTables);
        }

        internal static CLovenseToyManager __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CLovenseToyManager)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static CLovenseToyManager __GetInstance(__IntPtr native)
        {
            if (!NativeToManagedMap.TryGetValue(native, out var managed))
                throw new global::System.Exception("No managed instance was found");
            var result = (CLovenseToyManager)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static CLovenseToyManager __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CLovenseToyManagerInternal(native, skipVTables);
        }

        internal CLovenseToyManager(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        // DEBUG: CLovenseToyManager
        internal CLovenseToyManager()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::LovenseWrapper.CLovenseToyManager.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "LovenseWrapper.CLovenseToyManager");
        }

        // DEBUG: CLovenseToyManager
        internal CLovenseToyManager(global::LovenseWrapper.CLovenseToyManager _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::LovenseWrapper.CLovenseToyManager.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
            SetupVTables(GetType().FullName == "LovenseWrapper.CLovenseToyManager");
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            ((global::LovenseWrapper.CLovenseToyManager.__Internal*) __Instance)->vfptr_CLovenseToyManager = __VTables.Tables[0];
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Pass your token into Lovense framework</summary>
        // DEBUG: virtual bool SetDeveloperToken(const char *szToken) = 0
        public abstract bool SetDeveloperToken(string szToken);

        /// <summary>Subscription notification</summary>
        // DEBUG: virtual void RegisterEventCallBack(ILovenseSDKNotify * lovenseNotify) = 0
        public abstract void RegisterEventCallBack(global::LovenseWrapper.ILovenseSDKNotify lovenseNotify);

        /// <summary>Search for Lovense toys</summary>
        // DEBUG: virtual int StartSearchToy() = 0
        public abstract int StartSearchToy();

        /// <summary>Send a command to the toy</summary>
        /// <param name="toyId">toy ID</param>
        /// <param name="commandType">command</param>
        /// <param name="paramDict">command parameters</param>
        // DEBUG: virtual int SendCommand(const char * szToyID, CLovenseToy::CmdType cmd, int nParam) = 0
        public abstract int SendCommand(string szToyID, global::LovenseWrapper.CLovenseToy.CmdType cmd, int nParam);

        /// <summary>Connect a toy</summary>
        /// <param name="toyId">
        /// <para>toy ID</para>
        /// <para>If Successful connection successfully, will call LovenseToyConnectedStatus;</para>
        /// </param>
        // DEBUG: virtual int ConnectToToy(const char * szToyID) = 0
        public abstract int ConnectToToy(string szToyID);

        /// <summary>DisConnect a toy</summary>
        /// <param name="toyId">
        /// <para>toy ID</para>
        /// <para>return Successfully disconnected, will call LovenseToyConnectedStatus;</para>
        /// </param>
        // DEBUG: virtual int DisConnectedToy(const char *szToyID) = 0
        public abstract int DisConnectedToy(string szToyID);

        /// <summary>Get toy battery</summary>
        /// <param name="toyId">
        /// <para>toy ID</para>
        /// <para>return 0</para>
        /// </param>
        // DEBUG: virtual int GetToyBattery(const char* szToyID, int *battery_out) = 0
        public abstract int GetToyBattery(string szToyID, ref int battery_out);

        /// <summary>Stop searching</summary>
        public abstract int StopSearchToy
        {
            get;
        }

        #region Virtual table interop

        // bool SetDeveloperToken(const char *szToken) = 0
        private static global::LovenseWrapper.Delegates.Func_bool___IntPtr_string8 _SetDeveloperTokenDelegateInstance;

        private static bool _SetDeveloperTokenDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string szToken)
        {
            var __target = global::LovenseWrapper.CLovenseToyManager.__GetInstance(__instance);
            return __target.SetDeveloperToken(szToken);
        }

        // void RegisterEventCallBack(ILovenseSDKNotify * lovenseNotify) = 0
        private static global::LovenseWrapper.Delegates.Action___IntPtr___IntPtr _RegisterEventCallBackDelegateInstance;

        private static void _RegisterEventCallBackDelegateHook(__IntPtr __instance, __IntPtr lovenseNotify)
        {
            var __target = global::LovenseWrapper.CLovenseToyManager.__GetInstance(__instance);
            var __result0 = global::LovenseWrapper.ILovenseSDKNotify.__GetOrCreateInstance(lovenseNotify, false);
            __target.RegisterEventCallBack(__result0);
        }

        // int StartSearchToy() = 0
        private static global::LovenseWrapper.Delegates.Func_int___IntPtr _StartSearchToyDelegateInstance;

        private static int _StartSearchToyDelegateHook(__IntPtr __instance)
        {
            var __target = global::LovenseWrapper.CLovenseToyManager.__GetInstance(__instance);
            return __target.StartSearchToy();
        }

        // int StopSearchToy() = 0
        private static global::LovenseWrapper.Delegates.Func_int___IntPtr _StopSearchToyDelegateInstance;

        private static int _StopSearchToyDelegateHook(__IntPtr __instance)
        {
            var __target = global::LovenseWrapper.CLovenseToyManager.__GetInstance(__instance);
            return __target.StopSearchToy;
        }

        // int SendCommand(const char * szToyID, CLovenseToy::CmdType cmd, int nParam) = 0
        private static global::LovenseWrapper.Delegates.Func_int___IntPtr_string8_LovenseWrapper_CLovenseToy_CmdType_int _SendCommandDelegateInstance;

        private static int _SendCommandDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string szToyID, global::LovenseWrapper.CLovenseToy.CmdType cmd, int nParam)
        {
            var __target = global::LovenseWrapper.CLovenseToyManager.__GetInstance(__instance);
            return __target.SendCommand(szToyID, cmd, nParam);
        }

        // int ConnectToToy(const char * szToyID) = 0
        private static global::LovenseWrapper.Delegates.Func_int___IntPtr_string8 _ConnectToToyDelegateInstance;

        private static int _ConnectToToyDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string szToyID)
        {
            var __target = global::LovenseWrapper.CLovenseToyManager.__GetInstance(__instance);
            return __target.ConnectToToy(szToyID);
        }

        // int DisConnectedToy(const char *szToyID) = 0
        private static global::LovenseWrapper.Delegates.Func_int___IntPtr_string8 _DisConnectedToyDelegateInstance;

        private static int _DisConnectedToyDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string szToyID)
        {
            var __target = global::LovenseWrapper.CLovenseToyManager.__GetInstance(__instance);
            return __target.DisConnectedToy(szToyID);
        }

        // int GetToyBattery(const char* szToyID, int *battery_out) = 0
        private static global::LovenseWrapper.Delegates.Func_int___IntPtr_string8_intPtr _GetToyBatteryDelegateInstance;

        private static int _GetToyBatteryDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string szToyID, int* battery_out)
        {
            var __target = global::LovenseWrapper.CLovenseToyManager.__GetInstance(__instance);
            return __target.GetToyBattery(szToyID, ref *battery_out);
        }

        internal static class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[8];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();

            static VTableLoader()
            {
                _SetDeveloperTokenDelegateInstance += _SetDeveloperTokenDelegateHook;
                _RegisterEventCallBackDelegateInstance += _RegisterEventCallBackDelegateHook;
                _StartSearchToyDelegateInstance += _StartSearchToyDelegateHook;
                _StopSearchToyDelegateInstance += _StopSearchToyDelegateHook;
                _SendCommandDelegateInstance += _SendCommandDelegateHook;
                _ConnectToToyDelegateInstance += _ConnectToToyDelegateHook;
                _DisConnectedToyDelegateInstance += _DisConnectedToyDelegateHook;
                _GetToyBatteryDelegateInstance += _GetToyBatteryDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_SetDeveloperTokenDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RegisterEventCallBackDelegateInstance);
                Thunks[2] = Marshal.GetFunctionPointerForDelegate(_StartSearchToyDelegateInstance);
                Thunks[3] = Marshal.GetFunctionPointerForDelegate(_StopSearchToyDelegateInstance);
                Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SendCommandDelegateInstance);
                Thunks[5] = Marshal.GetFunctionPointerForDelegate(_ConnectToToyDelegateInstance);
                Thunks[6] = Marshal.GetFunctionPointerForDelegate(_DisConnectedToyDelegateInstance);
                Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetToyBatteryDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 8);
                            ManagedVTables[0][0] = Thunks[0];
                            ManagedVTables[0][1] = Thunks[1];
                            ManagedVTables[0][2] = Thunks[2];
                            ManagedVTables[0][3] = Thunks[3];
                            ManagedVTables[0][4] = Thunks[4];
                            ManagedVTables[0][5] = Thunks[5];
                            ManagedVTables[0][6] = Thunks[6];
                            ManagedVTables[0][7] = Thunks[7];
                            VTables.Methods[0] = new Delegate[8];
                            if (destructorOnly)
                                return VTables;
                        }
                    }
                }

                *(IntPtr**)(instance + 0) = ManagedVTables[0];
                return VTables;
            }
        }

        internal CppSharp.Runtime.VTables __vtables;
        internal virtual CppSharp.Runtime.VTables __VTables
        { 
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {        
                __vtables = value;
            }
        }

        internal virtual void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }

    public unsafe partial class ILovenseSDKNotifyInternal : global::LovenseWrapper.ILovenseSDKNotify, IDisposable
    {
        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal ILovenseSDKNotifyInternal(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal ILovenseSDKNotifyInternal(void* native, bool skipVTables = false)
            : base((void*) native)
        {
        }

        // DEBUG: virtual	void LovenseDidSearchStart() = 0
        public override void LovenseDidSearchStart()
        {
            var ___LovenseDidSearchStartDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Action___IntPtr>(0, 0);
            ___LovenseDidSearchStartDelegate(__Instance);
        }

        // DEBUG: virtual  void LovenseSearchingToys(lovense_toy_info_t *info) = 0
        public override void LovenseSearchingToys(global::LovenseWrapper.StLovenseToyInfo info)
        {
            var ___LovenseSearchingToysDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Action___IntPtr___IntPtr>(0, 1);
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            ___LovenseSearchingToysDelegate(__Instance, __arg0);
        }

        // DEBUG: virtual  void LovenseErrorOutPut(int errorCode,const char *errorMsg) = 0
        public override void LovenseErrorOutPut(int errorCode, string errorMsg)
        {
            var ___LovenseErrorOutPutDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Action___IntPtr_int_string8>(0, 2);
            ___LovenseErrorOutPutDelegate(__Instance, errorCode, errorMsg);
        }

        // DEBUG: virtual  void LovenseDidSearchEnd() = 0
        public override void LovenseDidSearchEnd()
        {
            var ___LovenseDidSearchEndDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Action___IntPtr>(0, 3);
            ___LovenseDidSearchEndDelegate(__Instance);
        }

        // DEBUG: virtual	void LovenseDidSendCmdStart() = 0
        public override void LovenseDidSendCmdStart()
        {
            var ___LovenseDidSendCmdStartDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Action___IntPtr>(0, 4);
            ___LovenseDidSendCmdStartDelegate(__Instance);
        }

        // DEBUG: virtual  void LovenseSendCmdResult(const char * szToyID, CLovenseToy::CmdType cmd,const char *result,CLovenseToy::Error errorCode) = 0
        public override void LovenseSendCmdResult(string szToyID, global::LovenseWrapper.CLovenseToy.CmdType cmd, string result, global::LovenseWrapper.CLovenseToy.Error errorCode)
        {
            var ___LovenseSendCmdResultDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Action___IntPtr_string8_LovenseWrapper_CLovenseToy_CmdType_string8_LovenseWrapper_CLovenseToy_Error>(0, 5);
            ___LovenseSendCmdResultDelegate(__Instance, szToyID, cmd, result, errorCode);
        }

        // DEBUG: virtual	void LovenseDidSendCmdEnd() = 0
        public override void LovenseDidSendCmdEnd()
        {
            var ___LovenseDidSendCmdEndDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Action___IntPtr>(0, 6);
            ___LovenseDidSendCmdEndDelegate(__Instance);
        }

        // DEBUG: virtual void LovenseToyConnectedStatus(const char *szToyID, bool isConnected) = 0
        public override void LovenseToyConnectedStatus(string szToyID, bool isConnected)
        {
            var ___LovenseToyConnectedStatusDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Action___IntPtr_string8_bool>(0, 7);
            ___LovenseToyConnectedStatusDelegate(__Instance, szToyID, isConnected);
        }
    }

    internal unsafe partial class CLovenseToyManagerInternal : global::LovenseWrapper.CLovenseToyManager, IDisposable
    {
        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal CLovenseToyManagerInternal(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal CLovenseToyManagerInternal(void* native, bool skipVTables = false)
            : base((void*) native)
        {
        }

        /// <summary>Pass your token into Lovense framework</summary>
        // DEBUG: virtual bool SetDeveloperToken(const char *szToken) = 0
        public override bool SetDeveloperToken(string szToken)
        {
            var ___SetDeveloperTokenDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Func_bool___IntPtr_string8>(0, 0);
            var __ret = ___SetDeveloperTokenDelegate(__Instance, szToken);
            return __ret;
        }

        /// <summary>Subscription notification</summary>
        // DEBUG: virtual void RegisterEventCallBack(ILovenseSDKNotify * lovenseNotify) = 0
        public override void RegisterEventCallBack(global::LovenseWrapper.ILovenseSDKNotify lovenseNotify)
        {
            var ___RegisterEventCallBackDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Action___IntPtr___IntPtr>(0, 1);
            var __arg0 = lovenseNotify is null ? __IntPtr.Zero : lovenseNotify.__Instance;
            ___RegisterEventCallBackDelegate(__Instance, __arg0);
        }

        /// <summary>Search for Lovense toys</summary>
        // DEBUG: virtual int StartSearchToy() = 0
        public override int StartSearchToy()
        {
            var ___StartSearchToyDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Func_int___IntPtr>(0, 2);
            var __ret = ___StartSearchToyDelegate(__Instance);
            return __ret;
        }

        /// <summary>Send a command to the toy</summary>
        /// <param name="toyId">toy ID</param>
        /// <param name="commandType">command</param>
        /// <param name="paramDict">command parameters</param>
        // DEBUG: virtual int SendCommand(const char * szToyID, CLovenseToy::CmdType cmd, int nParam) = 0
        public override int SendCommand(string szToyID, global::LovenseWrapper.CLovenseToy.CmdType cmd, int nParam)
        {
            var ___SendCommandDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Func_int___IntPtr_string8_LovenseWrapper_CLovenseToy_CmdType_int>(0, 4);
            var __ret = ___SendCommandDelegate(__Instance, szToyID, cmd, nParam);
            return __ret;
        }

        /// <summary>Connect a toy</summary>
        /// <param name="toyId">
        /// <para>toy ID</para>
        /// <para>If Successful connection successfully, will call LovenseToyConnectedStatus;</para>
        /// </param>
        // DEBUG: virtual int ConnectToToy(const char * szToyID) = 0
        public override int ConnectToToy(string szToyID)
        {
            var ___ConnectToToyDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Func_int___IntPtr_string8>(0, 5);
            var __ret = ___ConnectToToyDelegate(__Instance, szToyID);
            return __ret;
        }

        /// <summary>DisConnect a toy</summary>
        /// <param name="toyId">
        /// <para>toy ID</para>
        /// <para>return Successfully disconnected, will call LovenseToyConnectedStatus;</para>
        /// </param>
        // DEBUG: virtual int DisConnectedToy(const char *szToyID) = 0
        public override int DisConnectedToy(string szToyID)
        {
            var ___DisConnectedToyDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Func_int___IntPtr_string8>(0, 6);
            var __ret = ___DisConnectedToyDelegate(__Instance, szToyID);
            return __ret;
        }

        /// <summary>Get toy battery</summary>
        /// <param name="toyId">
        /// <para>toy ID</para>
        /// <para>return 0</para>
        /// </param>
        // DEBUG: virtual int GetToyBattery(const char* szToyID, int *battery_out) = 0
        public override int GetToyBattery(string szToyID, ref int battery_out)
        {
            var ___GetToyBatteryDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Func_int___IntPtr_string8_intPtr>(0, 7);
            fixed (int* __battery_out1 = &battery_out)
            {
                var __arg1 = __battery_out1;
                var __ret = ___GetToyBatteryDelegate(__Instance, szToyID, __arg1);
                return __ret;
            }
        }

        /// <summary>Stop searching</summary>
        public override int StopSearchToy
        {
            get
            {
                var ___StopSearchToyDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Func_int___IntPtr>(0, 3);
                var __ret = ___StopSearchToyDelegate(__Instance);
                return __ret;
            }
        }
    }

    public unsafe partial class Lovense
    {
        internal partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("LovenseToys", EntryPoint = "GetLovenseToyManager", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetLovenseToyManager();

            [SuppressUnmanagedCodeSecurity, DllImport("LovenseToys", EntryPoint = "ReleaseLovenseToyManager", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ReleaseLovenseToyManager();
        }

        /// <summary>Get the class instance through this export interface!</summary>
        // DEBUG: LOVENSE_EXTERN CLovenseToyManager * const GetLovenseToyManager()
        public static global::LovenseWrapper.CLovenseToyManager GetLovenseToyManager()
        {
            var __ret = __Internal.GetLovenseToyManager();
            var __result0 = global::LovenseWrapper.CLovenseToyManager.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Release worker context</summary>
        // DEBUG: LOVENSE_EXTERN void ReleaseLovenseToyManager()
        public static void ReleaseLovenseToyManager()
        {
            __Internal.ReleaseLovenseToyManager();
        }
    }

    // DEBUG: enum { 
    // DEBUG: 
    // DEBUG: 	//HID USB Dongle
    // DEBUG: 	DONGLE_HID_TYPE = 0,
    // DEBUG: 
    // DEBUG: 	//SERIAL COM USB Dongle
    // DEBUG: 	DONGLE_BLE_TYPE	= 1,
    // DEBUG: 
    // DEBUG: }
    public enum DongleType
    {
        DONGLE_HID_TYPE = 0,
        DONGLE_BLE_TYPE = 1
    }

    // DEBUG: enum {
    // DEBUG: 	LVS_UNKNOWN		= 0,
    // DEBUG: 	LVS_MAX			= 0x01,
    // DEBUG: 	LVS_NORA		= 0x02,
    // DEBUG: 	LVS_HUSH		= 0x03,
    // DEBUG: 	LVS_LUSH		= 0x04,
    // DEBUG: 	LVS_AMBI		= 0x05,
    // DEBUG: 	LVS_DOMI		= 0x06,
    // DEBUG: 	LVS_SECRET		= 0x07,
    // DEBUG: 	LVS_EDGE		= 0x08,
    // DEBUG: 	LVS_OSCI		= 0x09,
    // DEBUG: 	LVS_DONGLE		= 0x0A,
    // DEBUG: 	LVS_DIAMO		= 0x0B,
    // DEBUG: 	LVS_MISSION		= 0x0C,
    // DEBUG: 	LVS_V01			= 0x0D,
    // DEBUG: 	LVS_DOLCE		= 0x0E,
    // DEBUG: 	LVS_XMACHINE	= 0x0F,
    // DEBUG: 	LVS_HYPHY		= 0x10,
    // DEBUG: 	LVS_CALOR		= 0x11,
    // DEBUG: 	LVS_FERRI		= 0x12,
    // DEBUG: }
    public enum LVSToyType
    {
        LVS_UNKNOWN = 0,
        LVS_MAX = 1,
        LVS_NORA = 2,
        LVS_HUSH = 3,
        LVS_LUSH = 4,
        LVS_AMBI = 5,
        LVS_DOMI = 6,
        LVS_SECRET = 7,
        LVS_EDGE = 8,
        LVS_OSCI = 9,
        LVS_DONGLE = 10,
        LVS_DIAMO = 11,
        LVS_MISSION = 12,
        LVS_V01 = 13,
        LVS_DOLCE = 14,
        LVS_XMACHINE = 15,
        LVS_HYPHY = 16,
        LVS_CALOR = 17,
        LVS_FERRI = 18
    }

    // DEBUG: typedef enum { 
    // DEBUG: 
    // DEBUG: 	//HID USB Dongle
    // DEBUG: 	DONGLE_HID_TYPE = 0,
    // DEBUG: 
    // DEBUG: 	//SERIAL COM USB Dongle
    // DEBUG: 	DONGLE_BLE_TYPE	= 1,
    // DEBUG: 
    // DEBUG: }DongleType
    // DEBUG: typedef enum {
    // DEBUG: 	LVS_UNKNOWN		= 0,
    // DEBUG: 	LVS_MAX			= 0x01,
    // DEBUG: 	LVS_NORA		= 0x02,
    // DEBUG: 	LVS_HUSH		= 0x03,
    // DEBUG: 	LVS_LUSH		= 0x04,
    // DEBUG: 	LVS_AMBI		= 0x05,
    // DEBUG: 	LVS_DOMI		= 0x06,
    // DEBUG: 	LVS_SECRET		= 0x07,
    // DEBUG: 	LVS_EDGE		= 0x08,
    // DEBUG: 	LVS_OSCI		= 0x09,
    // DEBUG: 	LVS_DONGLE		= 0x0A,
    // DEBUG: 	LVS_DIAMO		= 0x0B,
    // DEBUG: 	LVS_MISSION		= 0x0C,
    // DEBUG: 	LVS_V01			= 0x0D,
    // DEBUG: 	LVS_DOLCE		= 0x0E,
    // DEBUG: 	LVS_XMACHINE	= 0x0F,
    // DEBUG: 	LVS_HYPHY		= 0x10,
    // DEBUG: 	LVS_CALOR		= 0x11,
    // DEBUG: 	LVS_FERRI		= 0x12,
    // DEBUG: }LVSToyType
    namespace CLovenseToy
    {
        // DEBUG: enum {
        // DEBUG: 		COMMAND_UNKNOWN = -1,
        // DEBUG: 
        // DEBUG: 		COMMAND_CONNECT_TOY = 0,
        // DEBUG: 
        // DEBUG: 		COMMAND_DISCONNECT_TOY = 1,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		-Power off!
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_POWER_OFF = 100,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Vibrate the toy .The parameter must be between 0 and 20!
        // DEBUG: 		- Supported toys = all
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_VIBRATE = 101,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Rotate the toy .The parameter must be between 0 and 20!
        // DEBUG: 		- Supported toys = Nora
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_ROTATE = 102,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Rotate clockwise .The parameter must be between 0 and 20!
        // DEBUG: 		- Supported toys = Nora
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_ROTATE_CLOCKWISE = 103,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Rotate anti-clockwise .The parameter must be between 0 and 20!
        // DEBUG: 		- Supported toys = Nora
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_ROTATE_ANTI_CLOCKWISE = 104,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Change the rotation direction
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		- Supported toys = Nora
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_ROTATE_CHANGE = 105,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Activate the first vibrator at level n .The parameter must be between 0 and 20!
        // DEBUG: 		- param Key = kSendCommandParamKey_VibrateLevel
        // DEBUG: 		- Supported toys = Edge
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_VIBRATE1 = 113,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Activate the second vibrator at level n .The parameter must be between 0 and 20!
        // DEBUG: 		- param Key = kSendCommandParamKey_VibrateLevel
        // DEBUG: 		- Supported toys = Edge
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_VIBRATE2 = 114,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Vibrate the toy at level n, and flash the light at the same time .The parameter must be between 0 and 20!
        // DEBUG: 		- param key = kSendCommandParamKey_VibrateLevel: vibration level (between 1~3)
        // DEBUG: 		- param key = kSendCommandParamKey_FlashLevel: Flashing frequency (per second). Between 0~9
        // DEBUG: 		- Supported toys = Ambi / Domi / Osci
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_VIBRATE_FLASH = 120,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Flash the light 3 times
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		- Supported toys = all
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_FLASH = 201,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Turn off the light (saved permanently)
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		- Supported toys = Lush / Hush / Edge
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_LIGHT_OFF = 210,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Turn on the light (saved permanently)
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		- Supported toys = Lush / Hush / Edge
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_LIGHT_ON = 211,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		Get the light status (1: on, 0:off)
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		* Supported toys = Lush  Hush  Edge
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_GET_LIGHT_STATUS = 212,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Turn off the AID light (saved permanently)
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		- Supported toys = Domi
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_ALIGHT_OFF = 220,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Turn on the AID light (saved permanently)
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		- Supported toys = Domi
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_ALIGHT_ON = 221,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		Get the AID light status (1: on, 0:off)
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		* Supported toys = Domi
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_GET_ALIGHT_STATUS = 222,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Get battery status,
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		* Supported toys = all
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_GET_BATTERY = 300,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		Get device/toy information
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		* Supported toys = all
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_GET_DEVICE_TYPE = 310,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		Inflatable n seconds. The parameter must be between (1-3)
        // DEBUG: 		* Supported toys = Max
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_AIR_IN						= 330,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		Deflation n seconds. The parameter must be between (1-3)
        // DEBUG: 		* Supported toys = Max
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_AIR_OUT					= 331,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		Cycle inflation for n seconds, deflation for n seconds, 0 for stop!
        // DEBUG: 		The parameter must be between (0-3)
        // DEBUG: 		* Supported toys = Max
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_AIR_AUTO				= 332,
        // DEBUG: 		
        // DEBUG: 		/**
        // DEBUG: 		Start tracking the toy movement (0-4)
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		* Supported toys = Max,Nora
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_START_MOVE = 400,
        // DEBUG: 
        // DEBUG: 		/*
        // DEBUG: 		Stop tracking the toy movement
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		* Supported toys = Max,Nora
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_STOP_MOVE = 401
        // DEBUG: 	}
        public enum CmdType
        {
            COMMAND_UNKNOWN = -1,
            COMMAND_CONNECT_TOY = 0,
            COMMAND_DISCONNECT_TOY = 1,
            /// <summary>
            /// <para>-Power off!</para>
            /// <para>- param Key = no parameter</para>
            /// </summary>
            COMMAND_POWER_OFF = 100,
            /// <summary>
            /// <para>- Vibrate the toy .The parameter must be between 0 and 20!</para>
            /// <para>- Supported toys = all</para>
            /// </summary>
            COMMAND_VIBRATE = 101,
            /// <summary>
            /// <para>- Rotate the toy .The parameter must be between 0 and 20!</para>
            /// <para>- Supported toys = Nora</para>
            /// </summary>
            COMMAND_ROTATE = 102,
            /// <summary>
            /// <para>- Rotate clockwise .The parameter must be between 0 and 20!</para>
            /// <para>- Supported toys = Nora</para>
            /// </summary>
            COMMAND_ROTATE_CLOCKWISE = 103,
            /// <summary>
            /// <para>- Rotate anti-clockwise .The parameter must be between 0 and 20!</para>
            /// <para>- Supported toys = Nora</para>
            /// </summary>
            COMMAND_ROTATE_ANTI_CLOCKWISE = 104,
            /// <summary>
            /// <para>- Change the rotation direction</para>
            /// <para>- param Key = no parameter</para>
            /// <para>- Supported toys = Nora</para>
            /// </summary>
            COMMAND_ROTATE_CHANGE = 105,
            /// <summary>
            /// <para>- Activate the first vibrator at level n .The parameter must be between 0 and 20!</para>
            /// <para>- param Key = kSendCommandParamKey_VibrateLevel</para>
            /// <para>- Supported toys = Edge</para>
            /// </summary>
            COMMAND_VIBRATE1 = 113,
            /// <summary>
            /// <para>- Activate the second vibrator at level n .The parameter must be between 0 and 20!</para>
            /// <para>- param Key = kSendCommandParamKey_VibrateLevel</para>
            /// <para>- Supported toys = Edge</para>
            /// </summary>
            COMMAND_VIBRATE2 = 114,
            /// <summary>
            /// <para>- Vibrate the toy at level n, and flash the light at the same time .The parameter must be between 0 and 20!</para>
            /// <para>- param key = kSendCommandParamKey_VibrateLevel: vibration level (between 1~3)</para>
            /// <para>- param key = kSendCommandParamKey_FlashLevel: Flashing frequency (per second). Between 0~9</para>
            /// <para>- Supported toys = Ambi / Domi / Osci</para>
            /// </summary>
            COMMAND_VIBRATE_FLASH = 120,
            /// <summary>
            /// <para>- Flash the light 3 times</para>
            /// <para>- param Key = no parameter</para>
            /// <para>- Supported toys = all</para>
            /// </summary>
            COMMAND_FLASH = 201,
            /// <summary>
            /// <para>- Turn off the light (saved permanently)</para>
            /// <para>- param Key = no parameter</para>
            /// <para>- Supported toys = Lush / Hush / Edge</para>
            /// </summary>
            COMMAND_LIGHT_OFF = 210,
            /// <summary>
            /// <para>- Turn on the light (saved permanently)</para>
            /// <para>- param Key = no parameter</para>
            /// <para>- Supported toys = Lush / Hush / Edge</para>
            /// </summary>
            COMMAND_LIGHT_ON = 211,
            /// <summary>
            /// <para>Get the light status (1: on, 0:off)</para>
            /// <para>- param Key = no parameter</para>
            /// <para>Supported toys = Lush  Hush  Edge</para>
            /// </summary>
            COMMAND_GET_LIGHT_STATUS = 212,
            /// <summary>
            /// <para>- Turn off the AID light (saved permanently)</para>
            /// <para>- param Key = no parameter</para>
            /// <para>- Supported toys = Domi</para>
            /// </summary>
            COMMAND_ALIGHT_OFF = 220,
            /// <summary>
            /// <para>- Turn on the AID light (saved permanently)</para>
            /// <para>- param Key = no parameter</para>
            /// <para>- Supported toys = Domi</para>
            /// </summary>
            COMMAND_ALIGHT_ON = 221,
            /// <summary>
            /// <para>Get the AID light status (1: on, 0:off)</para>
            /// <para>- param Key = no parameter</para>
            /// <para>Supported toys = Domi</para>
            /// </summary>
            COMMAND_GET_ALIGHT_STATUS = 222,
            /// <summary>
            /// <para>- Get battery status,</para>
            /// <para>- param Key = no parameter</para>
            /// <para>Supported toys = all</para>
            /// </summary>
            COMMAND_GET_BATTERY = 300,
            /// <summary>
            /// <para>Get device/toy information</para>
            /// <para>- param Key = no parameter</para>
            /// <para>Supported toys = all</para>
            /// </summary>
            COMMAND_GET_DEVICE_TYPE = 310,
            /// <summary>
            /// <para>Inflatable n seconds. The parameter must be between (1-3)</para>
            /// <para>Supported toys = Max</para>
            /// </summary>
            COMMAND_AIR_IN = 330,
            /// <summary>
            /// <para>Deflation n seconds. The parameter must be between (1-3)</para>
            /// <para>Supported toys = Max</para>
            /// </summary>
            COMMAND_AIR_OUT = 331,
            /// <summary>
            /// <para>Cycle inflation for n seconds, deflation for n seconds, 0 for stop!</para>
            /// <para>The parameter must be between (0-3)</para>
            /// <para>Supported toys = Max</para>
            /// </summary>
            COMMAND_AIR_AUTO = 332,
            /// <summary>
            /// <para>Start tracking the toy movement (0-4)</para>
            /// <para>- param Key = no parameter</para>
            /// <para>Supported toys = Max,Nora</para>
            /// </summary>
            COMMAND_START_MOVE = 400,
            /// <summary>
            /// <para>Start tracking the toy movement (0-4)</para>
            /// <para>- param Key = no parameter</para>
            /// <para>Supported toys = Max,Nora</para>
            /// </summary>
            COMMAND_STOP_MOVE = 401
        }

        // DEBUG: enum
        // DEBUG: 	{
        // DEBUG: 		TOYERR_UNKNOWN			= -1,
        // DEBUG: 
        // DEBUG: 		TOYERR_SUCCESS			= 0,
        // DEBUG: 
        // DEBUG: 		TOYERR_ABORT			= 1001,
        // DEBUG: 
        // DEBUG: 		//HID interface initialization failed!
        // DEBUG: 		TOYERR_HID_INIT_FAILED	= 1002,
        // DEBUG: 
        // DEBUG: 		//No HID USB Dongle found!
        // DEBUG: 		TOYERR_HID_DONGLE_NOT_FOUND	= 1003,
        // DEBUG: 
        // DEBUG: 		//Unable to get HID Dongle information!
        // DEBUG: 		TOYERR_HID_GET_DONGLE_ID_ERROR	= 1004,
        // DEBUG: 		
        // DEBUG: 		//Toys are not connected to USB Dongle!
        // DEBUG: 		TOYERR_TOY_NOT_CONNECTED	= 1005,		
        // DEBUG: 
        // DEBUG: 		//Invalid argument
        // DEBUG: 		TOYERR_PARAM_ERROR		= 1006,	
        // DEBUG: 
        // DEBUG: 		//Unrecognized command
        // DEBUG: 		TOYERR_INVALID_CMD	= 1007,			
        // DEBUG: 
        // DEBUG: 		//Invalid token
        // DEBUG: 		TOYERR_INVALIDTOKEN	= 1008,
        // DEBUG: 
        // DEBUG: 		//COM READ ERROR
        // DEBUG: 		TOYERR_COM_READ_ERROR = 1009,
        // DEBUG: 
        // DEBUG: 		//COM WRITE ERROR
        // DEBUG: 		TOYERR_COM_WRITE_ERROR = 1010,
        // DEBUG: 
        // DEBUG: 		//COM NOT FOUND ERROR
        // DEBUG: 		TOYERR_COM_NOT_FOUND_ERROR = 1011,
        // DEBUG: 		//HID READ ERROR
        // DEBUG: 		TOYERR_HID_READ_ERROR = 1012,
        // DEBUG: 
        // DEBUG: 		//HID WRITE ERROR
        // DEBUG: 		TOYERR_HID_WRITE_ERROR = 1013,
        // DEBUG: 
        // DEBUG: 		//DEVICE NOT FOUND
        // DEBUG: 		TOYERR_DONGLE_NO_FOUND_ERROR = 1014,
        // DEBUG: 
        // DEBUG: 		//HID DEVICE OPEN FAILED
        // DEBUG: 		TOYERR_HID_OPEN_FAILED_ERROR = 1015,
        // DEBUG: 
        // DEBUG: 		//COM DEVICE OPEN FAILED
        // DEBUG: 		TOYERR_COM_OPEN_FAILED_ERROR = 1016,
        // DEBUG: 
        // DEBUG: 		//device can not be write
        // DEBUG: 		TOYERR_DEVICE_WRITE_FAILED = 1017,
        // DEBUG: 
        // DEBUG: 		//device can not be read
        // DEBUG: 		TOYERR_DEVICE_READ_FAILED = 1018,
        // DEBUG: 
        // DEBUG: 		//device is searching, You can't send any commands
        // DEBUG: 		TOYERR_DEVICE_IS_SEARCHING = 1019,
        // DEBUG: 	}
        public enum Error
        {
            TOYERR_UNKNOWN = -1,
            TOYERR_SUCCESS = 0,
            TOYERR_ABORT = 1001,
            TOYERR_HID_INIT_FAILED = 1002,
            TOYERR_HID_DONGLE_NOT_FOUND = 1003,
            TOYERR_HID_GET_DONGLE_ID_ERROR = 1004,
            TOYERR_TOY_NOT_CONNECTED = 1005,
            TOYERR_PARAM_ERROR = 1006,
            TOYERR_INVALID_CMD = 1007,
            TOYERR_INVALIDTOKEN = 1008,
            TOYERR_COM_READ_ERROR = 1009,
            TOYERR_COM_WRITE_ERROR = 1010,
            TOYERR_COM_NOT_FOUND_ERROR = 1011,
            TOYERR_HID_READ_ERROR = 1012,
            TOYERR_HID_WRITE_ERROR = 1013,
            TOYERR_DONGLE_NO_FOUND_ERROR = 1014,
            TOYERR_HID_OPEN_FAILED_ERROR = 1015,
            TOYERR_COM_OPEN_FAILED_ERROR = 1016,
            TOYERR_DEVICE_WRITE_FAILED = 1017,
            TOYERR_DEVICE_READ_FAILED = 1018,
            TOYERR_DEVICE_IS_SEARCHING = 1019
        }
        // DEBUG: typedef enum {
        // DEBUG: 		COMMAND_UNKNOWN = -1,
        // DEBUG: 
        // DEBUG: 		COMMAND_CONNECT_TOY = 0,
        // DEBUG: 
        // DEBUG: 		COMMAND_DISCONNECT_TOY = 1,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		-Power off!
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_POWER_OFF = 100,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Vibrate the toy .The parameter must be between 0 and 20!
        // DEBUG: 		- Supported toys = all
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_VIBRATE = 101,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Rotate the toy .The parameter must be between 0 and 20!
        // DEBUG: 		- Supported toys = Nora
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_ROTATE = 102,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Rotate clockwise .The parameter must be between 0 and 20!
        // DEBUG: 		- Supported toys = Nora
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_ROTATE_CLOCKWISE = 103,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Rotate anti-clockwise .The parameter must be between 0 and 20!
        // DEBUG: 		- Supported toys = Nora
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_ROTATE_ANTI_CLOCKWISE = 104,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Change the rotation direction
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		- Supported toys = Nora
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_ROTATE_CHANGE = 105,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Activate the first vibrator at level n .The parameter must be between 0 and 20!
        // DEBUG: 		- param Key = kSendCommandParamKey_VibrateLevel
        // DEBUG: 		- Supported toys = Edge
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_VIBRATE1 = 113,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Activate the second vibrator at level n .The parameter must be between 0 and 20!
        // DEBUG: 		- param Key = kSendCommandParamKey_VibrateLevel
        // DEBUG: 		- Supported toys = Edge
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_VIBRATE2 = 114,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Vibrate the toy at level n, and flash the light at the same time .The parameter must be between 0 and 20!
        // DEBUG: 		- param key = kSendCommandParamKey_VibrateLevel: vibration level (between 1~3)
        // DEBUG: 		- param key = kSendCommandParamKey_FlashLevel: Flashing frequency (per second). Between 0~9
        // DEBUG: 		- Supported toys = Ambi / Domi / Osci
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_VIBRATE_FLASH = 120,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Flash the light 3 times
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		- Supported toys = all
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_FLASH = 201,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Turn off the light (saved permanently)
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		- Supported toys = Lush / Hush / Edge
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_LIGHT_OFF = 210,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Turn on the light (saved permanently)
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		- Supported toys = Lush / Hush / Edge
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_LIGHT_ON = 211,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		Get the light status (1: on, 0:off)
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		* Supported toys = Lush  Hush  Edge
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_GET_LIGHT_STATUS = 212,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Turn off the AID light (saved permanently)
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		- Supported toys = Domi
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_ALIGHT_OFF = 220,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Turn on the AID light (saved permanently)
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		- Supported toys = Domi
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_ALIGHT_ON = 221,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		Get the AID light status (1: on, 0:off)
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		* Supported toys = Domi
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_GET_ALIGHT_STATUS = 222,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		- Get battery status,
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		* Supported toys = all
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_GET_BATTERY = 300,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		Get device/toy information
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		* Supported toys = all
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_GET_DEVICE_TYPE = 310,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		Inflatable n seconds. The parameter must be between (1-3)
        // DEBUG: 		* Supported toys = Max
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_AIR_IN						= 330,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		Deflation n seconds. The parameter must be between (1-3)
        // DEBUG: 		* Supported toys = Max
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_AIR_OUT					= 331,
        // DEBUG: 
        // DEBUG: 		/**
        // DEBUG: 		Cycle inflation for n seconds, deflation for n seconds, 0 for stop!
        // DEBUG: 		The parameter must be between (0-3)
        // DEBUG: 		* Supported toys = Max
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_AIR_AUTO				= 332,
        // DEBUG: 		
        // DEBUG: 		/**
        // DEBUG: 		Start tracking the toy movement (0-4)
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		* Supported toys = Max,Nora
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_START_MOVE = 400,
        // DEBUG: 
        // DEBUG: 		/*
        // DEBUG: 		Stop tracking the toy movement
        // DEBUG: 		- param Key = no parameter
        // DEBUG: 		* Supported toys = Max,Nora
        // DEBUG: 		*/
        // DEBUG: 		COMMAND_STOP_MOVE = 401
        // DEBUG: 	} CmdType
        // DEBUG: typedef enum
        // DEBUG: 	{
        // DEBUG: 		TOYERR_UNKNOWN			= -1,
        // DEBUG: 
        // DEBUG: 		TOYERR_SUCCESS			= 0,
        // DEBUG: 
        // DEBUG: 		TOYERR_ABORT			= 1001,
        // DEBUG: 
        // DEBUG: 		//HID interface initialization failed!
        // DEBUG: 		TOYERR_HID_INIT_FAILED	= 1002,
        // DEBUG: 
        // DEBUG: 		//No HID USB Dongle found!
        // DEBUG: 		TOYERR_HID_DONGLE_NOT_FOUND	= 1003,
        // DEBUG: 
        // DEBUG: 		//Unable to get HID Dongle information!
        // DEBUG: 		TOYERR_HID_GET_DONGLE_ID_ERROR	= 1004,
        // DEBUG: 		
        // DEBUG: 		//Toys are not connected to USB Dongle!
        // DEBUG: 		TOYERR_TOY_NOT_CONNECTED	= 1005,		
        // DEBUG: 
        // DEBUG: 		//Invalid argument
        // DEBUG: 		TOYERR_PARAM_ERROR		= 1006,	
        // DEBUG: 
        // DEBUG: 		//Unrecognized command
        // DEBUG: 		TOYERR_INVALID_CMD	= 1007,			
        // DEBUG: 
        // DEBUG: 		//Invalid token
        // DEBUG: 		TOYERR_INVALIDTOKEN	= 1008,
        // DEBUG: 
        // DEBUG: 		//COM READ ERROR
        // DEBUG: 		TOYERR_COM_READ_ERROR = 1009,
        // DEBUG: 
        // DEBUG: 		//COM WRITE ERROR
        // DEBUG: 		TOYERR_COM_WRITE_ERROR = 1010,
        // DEBUG: 
        // DEBUG: 		//COM NOT FOUND ERROR
        // DEBUG: 		TOYERR_COM_NOT_FOUND_ERROR = 1011,
        // DEBUG: 		//HID READ ERROR
        // DEBUG: 		TOYERR_HID_READ_ERROR = 1012,
        // DEBUG: 
        // DEBUG: 		//HID WRITE ERROR
        // DEBUG: 		TOYERR_HID_WRITE_ERROR = 1013,
        // DEBUG: 
        // DEBUG: 		//DEVICE NOT FOUND
        // DEBUG: 		TOYERR_DONGLE_NO_FOUND_ERROR = 1014,
        // DEBUG: 
        // DEBUG: 		//HID DEVICE OPEN FAILED
        // DEBUG: 		TOYERR_HID_OPEN_FAILED_ERROR = 1015,
        // DEBUG: 
        // DEBUG: 		//COM DEVICE OPEN FAILED
        // DEBUG: 		TOYERR_COM_OPEN_FAILED_ERROR = 1016,
        // DEBUG: 
        // DEBUG: 		//device can not be write
        // DEBUG: 		TOYERR_DEVICE_WRITE_FAILED = 1017,
        // DEBUG: 
        // DEBUG: 		//device can not be read
        // DEBUG: 		TOYERR_DEVICE_READ_FAILED = 1018,
        // DEBUG: 
        // DEBUG: 		//device is searching, You can't send any commands
        // DEBUG: 		TOYERR_DEVICE_IS_SEARCHING = 1019,
        // DEBUG: 	}Error
    }

    // DEBUG: typedef struct st_lovense_toy_info {
    // DEBUG: 	char* toy_id;
    // DEBUG: 	char* toy_name;
    // DEBUG: 	int toy_battery;
    // DEBUG: 	int toy_type;
    // DEBUG: 	bool toy_connected;
    // DEBUG: }lovense_toy_info_t
    // DEBUG: struct st_lovense_toy_info {
    // DEBUG: 	char* toy_id;
    // DEBUG: 	char* toy_name;
    // DEBUG: 	int toy_battery;
    // DEBUG: 	int toy_type;
    // DEBUG: 	bool toy_connected;
    // DEBUG: }
    public unsafe partial class StLovenseToyInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        internal partial struct __Internal
        {
            internal __IntPtr toy_id;
            internal __IntPtr toy_name;
            internal int toy_battery;
            internal int toy_type;
            internal byte toy_connected;

            [SuppressUnmanagedCodeSecurity, DllImport("LovenseWrapper", EntryPoint = "??0st_lovense_toy_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        internal __IntPtr __Instance { get; private set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::LovenseWrapper.StLovenseToyInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::LovenseWrapper.StLovenseToyInfo>();

        internal bool __ownsNativeInstance;

        internal static StLovenseToyInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StLovenseToyInfo(native.ToPointer(), skipVTables);
        }

        internal static StLovenseToyInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (StLovenseToyInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static StLovenseToyInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StLovenseToyInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StLovenseToyInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal StLovenseToyInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        // DEBUG: st_lovense_toy_info
        internal StLovenseToyInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::LovenseWrapper.StLovenseToyInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        // DEBUG: st_lovense_toy_info
        internal StLovenseToyInfo(global::LovenseWrapper.StLovenseToyInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::LovenseWrapper.StLovenseToyInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::LovenseWrapper.StLovenseToyInfo.__Internal*) __Instance) = *((global::LovenseWrapper.StLovenseToyInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* ToyId
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->toy_id;
            }

            set
            {
                ((__Internal*)__Instance)->toy_id = (__IntPtr) value;
            }
        }

        public sbyte* ToyName
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->toy_name;
            }

            set
            {
                ((__Internal*)__Instance)->toy_name = (__IntPtr) value;
            }
        }

        public int ToyBattery
        {
            get
            {
                return ((__Internal*)__Instance)->toy_battery;
            }

            set
            {
                ((__Internal*)__Instance)->toy_battery = value;
            }
        }

        public int ToyType
        {
            get
            {
                return ((__Internal*)__Instance)->toy_type;
            }

            set
            {
                ((__Internal*)__Instance)->toy_type = value;
            }
        }

        public bool ToyConnected
        {
            get
            {
                return ((__Internal*)__Instance)->toy_connected != 0;
            }

            set
            {
                ((__Internal*)__Instance)->toy_connected = (byte) (value ? 1 : 0);
            }
        }
    }

    // DEBUG: class CToyInfo
    // DEBUG: {
    // DEBUG: public:
    // DEBUG: 	CToyInfo();
    // DEBUG: 	virtual	~CToyInfo();
    // DEBUG: 	virtual  const std::string & GetToyID() const ;
    // DEBUG: 	virtual  const std::string & GetToyName() const;
    // DEBUG: 	virtual  const std::string & GetToyFullName() const;
    // DEBUG: 	virtual  const std::string & GetToyVersion() const;
    // DEBUG: 	virtual   int GetBettary() const;
    // DEBUG: 	virtual   bool IsConnected() const;
    // DEBUG: 	virtual  LVSToyType GetToyType() const;
    // DEBUG: 
    // DEBUG: 	void SetToyID(const std::string & toyID);
    // DEBUG: 	void SetToyName(const std::string & toyName);
    // DEBUG: 	void SetToyFullName(const std::string & fullName);
    // DEBUG: 	void SetToyVersion(const std::string & version);
    // DEBUG: 	void SetToyConnected(bool connected);
    // DEBUG: 	void SetToyBettary(int bettary);
    // DEBUG: 	void SetToyType(LVSToyType type);
    // DEBUG: 
    // DEBUG: private:
    // DEBUG: 	std::string  m_strToyID;
    // DEBUG: 	std::string  m_strToyName;
    // DEBUG: 	std::string  m_strFullName;
    // DEBUG: 	std::string  m_strToyVersion;
    // DEBUG: 	bool		 m_isConnected = false;
    // DEBUG: 	int			 m_bettary = 0;
    // DEBUG: 	LVSToyType	 m_toyType;
    // DEBUG: }
    public unsafe partial class CToyInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 152)]
        internal partial struct __Internal
        {
            internal __IntPtr vfptr_CToyInfo;
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_strToyID;
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_strToyName;
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_strFullName;
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_strToyVersion;
            internal byte m_isConnected;
            internal int m_bettary;
            internal global::LovenseWrapper.LVSToyType m_toyType;

            [SuppressUnmanagedCodeSecurity, DllImport("LovenseWrapper", EntryPoint = "??0CToyInfo@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("LovenseWrapper", EntryPoint = "??0CToyInfo@@QEAA@AEBV0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("LovenseWrapper", EntryPoint = "?SetToyConnected@CToyInfo@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetToyConnected(__IntPtr __instance, bool connected);

            [SuppressUnmanagedCodeSecurity, DllImport("LovenseWrapper", EntryPoint = "?SetToyBettary@CToyInfo@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetToyBettary(__IntPtr __instance, int bettary);

            [SuppressUnmanagedCodeSecurity, DllImport("LovenseWrapper", EntryPoint = "?SetToyID@CToyInfo@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetToyID(__IntPtr __instance, __IntPtr toyID);

            [SuppressUnmanagedCodeSecurity, DllImport("LovenseWrapper", EntryPoint = "?SetToyName@CToyInfo@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetToyName(__IntPtr __instance, __IntPtr toyName);

            [SuppressUnmanagedCodeSecurity, DllImport("LovenseWrapper", EntryPoint = "?SetToyFullName@CToyInfo@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetToyFullName(__IntPtr __instance, __IntPtr fullName);

            [SuppressUnmanagedCodeSecurity, DllImport("LovenseWrapper", EntryPoint = "?SetToyVersion@CToyInfo@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetToyVersion(__IntPtr __instance, __IntPtr version);

            [SuppressUnmanagedCodeSecurity, DllImport("LovenseWrapper", EntryPoint = "?SetToyType@CToyInfo@@QEAAXW4LVSToyType@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetToyType(__IntPtr __instance, global::LovenseWrapper.LVSToyType type);
        }

        internal __IntPtr __Instance { get; private set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::LovenseWrapper.CToyInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::LovenseWrapper.CToyInfo>();

        protected bool __ownsNativeInstance;

        internal static CToyInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new CToyInfo(native.ToPointer(), skipVTables);
        }

        internal static CToyInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CToyInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static CToyInfo __GetInstance(__IntPtr native)
        {
            if (!NativeToManagedMap.TryGetValue(native, out var managed))
                throw new global::System.Exception("No managed instance was found");
            var result = (CToyInfo)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static CToyInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CToyInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::LovenseWrapper.CToyInfo.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private CToyInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal CToyInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
            if (!skipVTables)
                SetupVTables(true);
        }

        // DEBUG: CToyInfo()
        internal CToyInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::LovenseWrapper.CToyInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "LovenseWrapper.CToyInfo");
        }

        // DEBUG: CToyInfo
        internal CToyInfo(global::LovenseWrapper.CToyInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::LovenseWrapper.CToyInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
            SetupVTables(GetType().FullName == "LovenseWrapper.CToyInfo");
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            ((global::LovenseWrapper.CToyInfo.__Internal*) __Instance)->vfptr_CToyInfo = __VTables.Tables[0];
            DisposePartial(disposing);
            if (callNativeDtor)
            {
                var ___dtorDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Action___IntPtr_int>(0, 0);
                ___dtorDelegate(__Instance, 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        // DEBUG: void SetToyConnected(bool connected)
        public void SetToyConnected(bool connected)
        {
            __Internal.SetToyConnected(__Instance, connected);
        }

        // DEBUG: void SetToyBettary(int bettary)
        public void SetToyBettary(int bettary)
        {
            __Internal.SetToyBettary(__Instance, bettary);
        }

        public virtual string ToyID
        {
            get
            {
                var ___GetToyIDDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Func___IntPtr___IntPtr>(0, 1);
                var __ret = ___GetToyIDDelegate(__Instance);
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                return global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            set
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, value);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetToyID(__Instance, __arg0);
                __basicString0.Dispose();
            }
        }

        public virtual string ToyName
        {
            get
            {
                var ___GetToyNameDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Func___IntPtr___IntPtr>(0, 2);
                var __ret = ___GetToyNameDelegate(__Instance);
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                return global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            set
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, value);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetToyName(__Instance, __arg0);
                __basicString0.Dispose();
            }
        }

        public virtual string ToyFullName
        {
            get
            {
                var ___GetToyFullNameDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Func___IntPtr___IntPtr>(0, 3);
                var __ret = ___GetToyFullNameDelegate(__Instance);
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                return global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            set
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, value);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetToyFullName(__Instance, __arg0);
                __basicString0.Dispose();
            }
        }

        public virtual string ToyVersion
        {
            get
            {
                var ___GetToyVersionDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Func___IntPtr___IntPtr>(0, 4);
                var __ret = ___GetToyVersionDelegate(__Instance);
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                return global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            set
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, value);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetToyVersion(__Instance, __arg0);
                __basicString0.Dispose();
            }
        }

        public virtual int Bettary
        {
            get
            {
                var ___GetBettaryDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Func_int___IntPtr>(0, 5);
                var __ret = ___GetBettaryDelegate(__Instance);
                return __ret;
            }
        }

        public virtual bool IsConnected
        {
            get
            {
                var ___IsConnectedDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Func_bool___IntPtr>(0, 6);
                var __ret = ___IsConnectedDelegate(__Instance);
                return __ret;
            }
        }

        public virtual global::LovenseWrapper.LVSToyType ToyType
        {
            get
            {
                var ___GetToyTypeDelegate = __VTables.GetMethodDelegate<global::LovenseWrapper.Delegates.Func_LovenseWrapper_LVSToyType___IntPtr>(0, 7);
                var __ret = ___GetToyTypeDelegate(__Instance);
                return __ret;
            }

            set
            {
                __Internal.SetToyType(__Instance, value);
            }
        }

        #region Virtual table interop

        // virtual ~CToyInfo()
        private static global::LovenseWrapper.Delegates.Action___IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(__IntPtr __instance, int delete)
        {
            var __target = global::LovenseWrapper.CToyInfo.__GetInstance(__instance);
            __target.Dispose(disposing: true, callNativeDtor: true);
        }

        // std::string & GetToyID() const
        private static global::LovenseWrapper.Delegates.Func___IntPtr___IntPtr _GetToyIDDelegateInstance;

        private static __IntPtr _GetToyIDDelegateHook(__IntPtr __instance)
        {
            var __target = global::LovenseWrapper.CToyInfo.__GetInstance(__instance);
            var __ret = __target.ToyID;
            var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString0, __ret);
            return __basicString0.__Instance;
        }

        // std::string & GetToyName() const
        private static global::LovenseWrapper.Delegates.Func___IntPtr___IntPtr _GetToyNameDelegateInstance;

        private static __IntPtr _GetToyNameDelegateHook(__IntPtr __instance)
        {
            var __target = global::LovenseWrapper.CToyInfo.__GetInstance(__instance);
            var __ret = __target.ToyName;
            var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString0, __ret);
            return __basicString0.__Instance;
        }

        // std::string & GetToyFullName() const
        private static global::LovenseWrapper.Delegates.Func___IntPtr___IntPtr _GetToyFullNameDelegateInstance;

        private static __IntPtr _GetToyFullNameDelegateHook(__IntPtr __instance)
        {
            var __target = global::LovenseWrapper.CToyInfo.__GetInstance(__instance);
            var __ret = __target.ToyFullName;
            var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString0, __ret);
            return __basicString0.__Instance;
        }

        // std::string & GetToyVersion() const
        private static global::LovenseWrapper.Delegates.Func___IntPtr___IntPtr _GetToyVersionDelegateInstance;

        private static __IntPtr _GetToyVersionDelegateHook(__IntPtr __instance)
        {
            var __target = global::LovenseWrapper.CToyInfo.__GetInstance(__instance);
            var __ret = __target.ToyVersion;
            var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString0, __ret);
            return __basicString0.__Instance;
        }

        // int GetBettary() const
        private static global::LovenseWrapper.Delegates.Func_int___IntPtr _GetBettaryDelegateInstance;

        private static int _GetBettaryDelegateHook(__IntPtr __instance)
        {
            var __target = global::LovenseWrapper.CToyInfo.__GetInstance(__instance);
            return __target.Bettary;
        }

        // bool IsConnected() const
        private static global::LovenseWrapper.Delegates.Func_bool___IntPtr _IsConnectedDelegateInstance;

        private static bool _IsConnectedDelegateHook(__IntPtr __instance)
        {
            var __target = global::LovenseWrapper.CToyInfo.__GetInstance(__instance);
            return __target.IsConnected;
        }

        // LVSToyType GetToyType() const
        private static global::LovenseWrapper.Delegates.Func_LovenseWrapper_LVSToyType___IntPtr _GetToyTypeDelegateInstance;

        private static global::LovenseWrapper.LVSToyType _GetToyTypeDelegateHook(__IntPtr __instance)
        {
            var __target = global::LovenseWrapper.CToyInfo.__GetInstance(__instance);
            var __ret = __target.ToyType;
            return __ret;
        }

        internal static class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[8];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();

            static VTableLoader()
            {
                _dtorDelegateInstance += _dtorDelegateHook;
                _GetToyIDDelegateInstance += _GetToyIDDelegateHook;
                _GetToyNameDelegateInstance += _GetToyNameDelegateHook;
                _GetToyFullNameDelegateInstance += _GetToyFullNameDelegateHook;
                _GetToyVersionDelegateInstance += _GetToyVersionDelegateHook;
                _GetBettaryDelegateInstance += _GetBettaryDelegateHook;
                _IsConnectedDelegateInstance += _IsConnectedDelegateHook;
                _GetToyTypeDelegateInstance += _GetToyTypeDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetToyIDDelegateInstance);
                Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetToyNameDelegateInstance);
                Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetToyFullNameDelegateInstance);
                Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetToyVersionDelegateInstance);
                Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetBettaryDelegateInstance);
                Thunks[6] = Marshal.GetFunctionPointerForDelegate(_IsConnectedDelegateInstance);
                Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetToyTypeDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 8);
                            ManagedVTablesDtorOnly[0][0] = Thunks[0];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 8);
                            ManagedVTables[0][0] = Thunks[0];
                            ManagedVTables[0][1] = Thunks[1];
                            ManagedVTables[0][2] = Thunks[2];
                            ManagedVTables[0][3] = Thunks[3];
                            ManagedVTables[0][4] = Thunks[4];
                            ManagedVTables[0][5] = Thunks[5];
                            ManagedVTables[0][6] = Thunks[6];
                            ManagedVTables[0][7] = Thunks[7];
                            VTables.Methods[0] = new Delegate[8];
                        }
                    }
                }

                if (destructorOnly)
                {
                    *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                }
                else
                {
                    *(IntPtr**)(instance + 0) = ManagedVTables[0];
                }
                return VTables;
            }
        }

        protected CppSharp.Runtime.VTables __vtables;
        internal virtual CppSharp.Runtime.VTables __VTables
        { 
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {        
                __vtables = value;
            }
        }

        internal virtual void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int_string8(__IntPtr __instance, int arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_string8_LovenseWrapper_CLovenseToy_CmdType_string8_LovenseWrapper_CLovenseToy_Error(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, global::LovenseWrapper.CLovenseToy.CmdType arg2, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg3, global::LovenseWrapper.CLovenseToy.Error arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_string8_bool(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, [MarshalAs(UnmanagedType.I1)] bool arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr_string8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate int Func_int___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate int Func_int___IntPtr_string8_LovenseWrapper_CLovenseToy_CmdType_int(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, global::LovenseWrapper.CLovenseToy.CmdType arg2, int arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate int Func_int___IntPtr_string8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate int Func_int___IntPtr_string8_intPtr(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, int* arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int(__IntPtr __instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::LovenseWrapper.LVSToyType Func_LovenseWrapper_LVSToyType___IntPtr(__IntPtr __instance);
    }
}
